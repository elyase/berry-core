use std::sync::Arc;

use anyhow::{Context, Result};
use arrow::{
    array::{builder, Array, BinaryArray, RecordBatch},
    compute::CastOptions,
    datatypes::{DataType, Field, Schema},
};

/// Casts columns according to given (column name, target data type) pairs.
///
/// Returns error if casting a row fails and `allow_cast_fail` is set to `false`.
/// Writes `null` to output if casting a row fails and `allow_cast_fail` is set to `true`.
pub fn cast<S: AsRef<str>>(
    map: &[(S, DataType)],
    data: &RecordBatch,
    allow_cast_fail: bool,
) -> Result<RecordBatch> {
    let schema = cast_schema(map, data.schema_ref()).context("cast schema")?;

    let mut arrays = Vec::with_capacity(data.num_columns());

    let cast_opt = CastOptions {
        safe: !allow_cast_fail,
        ..Default::default()
    };

    for (col, field) in data.columns().iter().zip(data.schema_ref().fields().iter()) {
        let cast_target = map.iter().find(|x| x.0.as_ref() == field.name());

        let col = match cast_target {
            Some(tgt) => Arc::new(
                arrow::compute::cast_with_options(col, &tgt.1, &cast_opt)
                    .with_context(|| format!("Failed when casting column '{}'", field.name()))?,
            ),
            None => col.clone(),
        };

        arrays.push(col);
    }

    let batch = RecordBatch::try_new(Arc::new(schema), arrays).context("construct record batch")?;

    Ok(batch)
}

/// Casts column types according to given (column name, target data type) pairs.
pub fn cast_schema<S: AsRef<str>>(map: &[(S, DataType)], schema: &Schema) -> Result<Schema> {
    let mut fields = schema.fields().to_vec();

    for f in fields.iter_mut() {
        let cast_target = map.iter().find(|x| x.0.as_ref() == f.name());

        if let Some(tgt) = cast_target {
            *f = Arc::new(Field::new(f.name(), tgt.1.clone(), f.is_nullable()));
        }
    }

    Ok(Schema::new(fields))
}

/// Encodes binary columns as prefixed hex format. e.g. 0xabcd
pub fn encode_prefix_hex(data: &RecordBatch) -> Result<RecordBatch> {
    encode_hex_impl::<true>(data)
} 

/// Encodes binary columns as hex format. e.g. a15b7cc1d
pub fn encode_hex(data: &RecordBatch) -> Result<RecordBatch> {
    encode_hex_impl::<false>(data)
} 

fn encode_hex_impl<const PREFIXED: bool>(data: &RecordBatch) -> Result<RecordBatch> {
    let schema = schema_binary_to_string(&data.schema_ref());
    let mut columns = Vec::with_capacity(data.columns().len());

    for col in data.columns().iter() {
        if col.data_type() == &DataType::Binary {
            
        } else {
            columns.push(col.clone());
        }
    }

    RecordBatch::try_new(Arc::new(schema), columns).context("construct arrow batch")
}

pub fn hex_encode_column<const PREFIXED: bool>(col: &BinaryArray) -> StringArray {
    let mut arr = builder::StringBuilder::with_capacity(col.len(), col.value_data().len() * 2);

    for v in col.iter() {
        match v {
            Some(v) => {

            }
            None => arr.append_null(),
        }
    }

    arr.finish()
}

/// Converts binary fields to string in the schema
///
/// Intended to be used with encode hex functions
pub fn schema_binary_to_string(schema: &Schema) -> Schema {
    todo!()
}

